// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::milestoning::*;
import meta::analytics::mapping::modelCoverage::utility::*;
import  meta::analytics::mapping::modelCoverage::*;

function meta::analytics::mapping::modelCoverage::utility::getValue<X, Y>(pairs : meta::pure::functions::collection::Pair<X, Y>[*], key : X[1]) : Y[1]
{
   let r = newMap($pairs)->get($key);
   assert($r->isNotEmpty(), | 'No value found for ' + $key->makeString() + if($pairs->size() < 15 && ($key->instanceOf(String) || $key->instanceOf(Enumeration)), |', expected one of ' + $pairs.first->map(x|$x->makeString())->sort()->joinStrings('[', ',', ']'), |''));
   $r->toOne();
}

function meta::analytics::mapping::modelCoverage::utility::getValue<X, Y>(pairs : meta::pure::functions::collection::Pair<X, Y>[*], key : X[1], defaultValue : Y[1]) : Y[1]
{
   let r = newMap($pairs)->get($key);
   if ($r->isEmpty(),
          | $defaultValue,
          | $r->toOne();
       );
}

function meta::analytics::mapping::modelCoverage::utility::findValues<X, Y>(pairs : Pair<X, Y>[*], value : X[1]) : Y[*]
{
   $pairs->filter(p|$p.first == $value)->map(p | $p.second)
}

function meta::analytics::mapping::modelCoverage::utility::qualifiedProperties(class:Class<Any>[1]):QualifiedProperty<Any>[*]
{
   $class->generalizations()->init()->cast(@Class<Any>)->map(c |
      $c.qualifiedProperties->concatenate($c.qualifiedPropertiesFromAssociations));
}

function meta::analytics::mapping::modelCoverage::utility::buildQualifiers(property : AbstractProperty<Any>[1]) : meta::analytics::mapping::modelCoverage::MappedPropertyQualifier[*]
{
   // no need to keep milestoning parameter information
   let isAutoMilestonedProperty = $property->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype();
   $property->match([
      {qp:QualifiedProperty<Any>[1] |
         let parameters = $qp->functionType().parameters->drop(1)->evaluateAndDeactivate()->filter(p | !$p.name->in(['businessDate', 'processingDate']));      
         let parameterNameValues = list($parameters->map(p | pair($p.name, list([]))));
         assert($parameters->size() == $parameterNameValues.values->size(), 'incorrect number of qualifier property arguments');
         let qualifiers = $parameters->zip($parameterNameValues.values);
         $qualifiers->map(q |
            let p = $q.first;
            let nameValues = $q.second;           
            let name = $nameValues.first;                    
            let paramType = $p.genericType.rawType->toOne();                                                        
            let multiplicity = if ($isAutoMilestonedProperty, | ZeroOne, | $p.multiplicity);          
            $paramType->match([
				pt:PrimitiveType[1] |  
					 let type = $paramType->mapType();
					 ^MappedPropertyQualifier(
						 name=$name,
						 type=$type,
						 multiplicity = $multiplicity
					  );,
				et:Enumeration<Any>[1] |  
					 ^MappedPropertyEnumQualifier(
              name=$name,
              type= MappedPropertyType.Enumeration, 
              multiplicity = $multiplicity,
              enumName = $et->elementToPath()
            );            
          ]);
         );
      }, 
      {ap:AbstractProperty<Any>[1]|[]}
      ]);
}